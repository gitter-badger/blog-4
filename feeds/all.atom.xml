<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>ひつまぶし食べたい</title><link href="http://www.hitsumabushi.org/" rel="alternate"></link><link href="http://www.hitsumabushi.org/feeds/all.atom.xml" rel="self"></link><id>http://www.hitsumabushi.org/</id><updated>2014-12-30T05:48:00+09:00</updated><entry><title>VPCの学習中のメモ</title><link href="http://www.hitsumabushi.org/2014/1230_0548.html" rel="alternate"></link><updated>2014-12-30T05:48:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-30:2014/1230_0548.html</id><summary type="html">&lt;p&gt;項目分けするほどでもないが、知っておくとVCP受講時に役にたつことをメモしていきます。&lt;br /&gt;
特に、あまり使われていない機能については、調べてないとわからないことが多いと思うので、参考になればと思います。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#vmware-data-recovery"&gt;VMware Data Recovery&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;概要&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;デプロイ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;動作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;上限&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#vmware-data-protection"&gt;VMware Data Protection&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_6"&gt;資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;概要&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;ライセンス体系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;メモリ&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_10"&gt;資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#esxi"&gt;ESXiメモリ使用方法順&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_11"&gt;リソース管理/パフォーマンスに関係する機能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="vmware-data-recovery"&gt;VMware Data Recovery&lt;/h2&gt;
&lt;h3 id="_1"&gt;資料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.vmware.com/files/jp/pdf/VMware-Data-Recovery-AG-JA.pdf"&gt;VMware Data Recovery 管理ガイド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.vmware.com/files/jp/pdf/data_recovery_datasheet.pdf"&gt;VMware Data Recovery Datasheet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;概要&lt;/h3&gt;
&lt;h4 id="_3"&gt;デプロイ&lt;/h4&gt;
&lt;p&gt;OVF形式で提供されているので、OVF deployします。&lt;/p&gt;
&lt;h4 id="_4"&gt;動作&lt;/h4&gt;
&lt;p&gt;VMware vStorage API for Data Protectionを使って、バックアップを取得します。&lt;br /&gt;
そのためVSSが利用でき、Windows 2003以降であれば、ファイルシステムの整合性を保つレベルでのスナップショットが取得できます。&lt;/p&gt;
&lt;p&gt;また、データの重複排除(デデュープ)を行うため、そこそこのデータ削減が見込めます。&lt;/p&gt;
&lt;h4 id="_5"&gt;上限&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;保護VMは、100VM/1アプライアンス&lt;/li&gt;
&lt;li&gt;10アプライアンス/1vCenter&lt;/li&gt;
&lt;li&gt;デデュープ ストアは、最大1TB&lt;ul&gt;
&lt;li&gt;CIFSのとき、500GB&lt;/li&gt;
&lt;li&gt;VMDK, RDMのとき、1TB&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="vmware-data-protection"&gt;VMware Data Protection&lt;/h2&gt;
&lt;h3 id="_6"&gt;資料&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.vmware.com/jp/support/support-resources/pubs/vdr_pubs"&gt;VMware vSphere Data Protection のドキュメント&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_7"&gt;概要&lt;/h3&gt;
&lt;p&gt;VMware Data Recoveryの後継みたいなものっぽいです。&lt;/p&gt;
&lt;p&gt;発展した点としては、以下がありそうです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;FLR(File Level Restore) をサポート&lt;/li&gt;
&lt;li&gt;サポート台数の増加&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_8"&gt;ライセンス体系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VMware Data Protection&lt;/li&gt;
&lt;li&gt;VMware Data Protection Advanced&lt;br /&gt;
の2つあって、いくつか違いがあります。特に、容量について、VMware Data Protectionは2TBまで。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_9"&gt;メモリ&lt;/h2&gt;
&lt;h3 id="_10"&gt;資料&lt;/h3&gt;
&lt;p&gt;以下のブログ記事を見ておけば、万事解決です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/takaochan/20110111/1294755765"&gt;VMware ESXにおけるメモリ管理(10) - メモリ圧縮 (1) - Simple is Beautiful&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/takaochan/20110321/1300718342"&gt;VMware ESXにおけるメモリ管理(12) - いつ、どのタイミングで、どの機能が使用されるのか - Simple is Beautiful&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;実際のメモリ情報の見方について、参考になります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blogs.vmware.com/jp-cim/2014/04/vcenter_memory.html"&gt;vCenterで確認できるメモリ情報の見方について | Japan Cloud Infrastructure Blog - VMware Blogs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="esxi"&gt;ESXiメモリ使用方法順&lt;/h3&gt;
&lt;p&gt;メモリの不足状況に応じて、以下の順番で各機能が利用されます。&lt;br /&gt;
後のものほど、VMのパフォーマンスへの影響が大きいです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TPS&lt;/li&gt;
&lt;li&gt;バルーニング&lt;/li&gt;
&lt;li&gt;メモリ圧縮&lt;/li&gt;
&lt;li&gt;SSDホストキャッシュ&lt;/li&gt;
&lt;li&gt;VMkernelスワッピング&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="_11"&gt;リソース管理/パフォーマンスに関係する機能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TPS&lt;/p&gt;
&lt;p&gt;透過的メモリ共有の機能。セキュリティ上の理由により、デフォルトでオフになります。&lt;br /&gt;
ホストマシンにおいて、仮想マシン間のメモリ内容が同じ時には、共通の物理メモリアドレスを参照させ、変更時にはCoWで行います。&lt;br /&gt;
これにより、物理メモリを節約することができます。ただ、ラージページが一般的になってきた最近のOSでは、それほど効果はありません。&lt;/p&gt;
&lt;p&gt;TPSの設定は、ホスト単位で設定できますが、全VMで共有する以外にも、VMごとにシードを与えることで、同じシードを持つVMだけでTPSを有効にすることが可能です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;バルーニング&lt;/p&gt;
&lt;p&gt;ESXiがVMに割り当てているメモリを回収するための技術です。&lt;br /&gt;
ESXiはVMにメモリを割り当てることはできますが、回収する方法があまりないため、ホストメモリが不足がちになってきたときにバルーニングを使います。&lt;/p&gt;
&lt;p&gt;バルーニングのために使われるバルーンドライバ(vmmemctlドライバ)は、VMware Toolsに含まれており、ゲストOS内のプロセスとして常駐しています。&lt;/p&gt;
&lt;p&gt;動作としては、ESXiから指示があった時、vmmemctlはゲストOS内でメモリを確保しようとします。&lt;br /&gt;
そうすると、ゲストOSはメモリをスワップアウトするなどして、vmmemctlへメモリを割り当てるので、割り当てられたメモリをESXiに渡すことができます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;メモリ圧縮&lt;/p&gt;
&lt;p&gt;VMメモリ領域の一部を圧縮し、物理メモリの節約をする技術です。&lt;/p&gt;
&lt;p&gt;圧縮前に圧縮率を計算し、50%以上であれば実施します。&lt;br /&gt;
圧縮したメモリ領域を使用する場合、解凍処理を行う必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SSDホストキャッシュ&lt;/p&gt;
&lt;p&gt;vswapファイルをSSD上に作成して、ESXiのメモリが不足した時にSSD上にスワップアウトする機能です。&lt;br /&gt;
後述するスワッピング処理を高速にするための技術です。&lt;br /&gt;
通常は、vswapファイルはVMのディレクトリと同じディレクトリに作られ、高速でないこともありますが、&lt;br /&gt;
この機能を使うことで、スワップアウトを高速にすることができます。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;VMkernelスワッピング&lt;/p&gt;
&lt;p&gt;ESXiの物理メモリが不足した時に、各VMのメモリ(の一部または全て)を vswapファイルにスワップする機能です。&lt;/p&gt;
&lt;p&gt;とにかくパフォーマンスが低下するため、パフォーマンストラブル時にもっとも気にする機能です。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="VCP-DCV"></category><category term="VMware"></category></entry><entry><title>VMware環境でのNPIVについて</title><link href="http://www.hitsumabushi.org/2014/1230_0257.html" rel="alternate"></link><updated>2014-12-30T02:57:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-30:2014/1230_0257.html</id><summary type="html">&lt;p&gt;VCP-DCV取得のために勉強していたところ、NPIVという用語が出てきたので、調べてみたことを書いておきます。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#npiv"&gt;NPIVとは&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#fc"&gt;FC環境の基本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#npiv_1"&gt;NPIV&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#vmware"&gt;VMware環境で利用する際の制限&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;資料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://pubs.vmware.com/vsphere-50/index.jsp?topic=/com.vmware.vsphere.vm_admin.doc_50/GUID-C713BCA5-71B4-4539-A4AE-8E781330755C.html"&gt;vSphere ドキュメント センター&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.itmedia.co.jp/enterprise/articles/0903/23/news002.html"&gt;サーバ仮想化のカギはストレージ・ネットワークにあり：基幹系サーバ統合に適したストレージ・ネットワーク要件を探れ！ - ITmedia エンタープライズ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://itpro.nikkeibp.co.jp/article/COLUMN/20090417/328662/"&gt;ブレードサーバーで始めるSAN - 第4回 ブレードサーバー特有のSAN設計：ITpro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;まとめ&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;NPIV = N_Port ID Virtualization&lt;/li&gt;
&lt;li&gt;NPIVとは、1つのHBAに対して複数のID(WWPN)を割り当てることで、&lt;strong&gt;1つのHBAポートを複数のHBAポートに見せる&lt;/strong&gt; ための技術&lt;/li&gt;
&lt;li&gt;VMware的には、RDMのディスクを持つ仮想マシンについて、 アクセス制御, QoSなどのために使われる&lt;/li&gt;
&lt;li&gt;NPIVのしようとして、1ポートあたり255WWPNしか割り当てられない&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="npiv"&gt;NPIVとは&lt;/h2&gt;
&lt;h3 id="fc"&gt;FC環境の基本&lt;/h3&gt;
&lt;p&gt;FC環境では、各ノードはWWN(&lt;em&gt;World Wide Name&lt;/em&gt;)を用いて識別されています。&lt;br /&gt;
IPプロトコルで言うところの、IPアドレスと同様に、アクセス先を表したり、アクセス制限を行ったりする対象が、WWNになります。&lt;/p&gt;
&lt;p&gt;このWWNは、&lt;br /&gt;
- WWNN (&lt;em&gt;World Wide Node Name&lt;/em&gt;)&lt;br /&gt;
- WWPN (&lt;em&gt;World Wide Port Name&lt;/em&gt;)&lt;br /&gt;
という2種類で構成されています(が、便宜的なものなので、通常、区別する必要はないです)。&lt;br /&gt;
その名の通り、WWNNはノード自身(例えば、HBAごと)に割り当てておき、WWPNはポート(例えば、HBAポートごと)に割り当てておきます。&lt;/p&gt;
&lt;h3 id="npiv_1"&gt;NPIV&lt;/h3&gt;
&lt;p&gt;前述の通り、WWNベースでアクセス制限をすることになるのですが、例えば、1つのHBAポートを複数のマシンで共有している状況で、&lt;br /&gt;
各マシンごとにアクセスできるLUN(LUNはWWNを持っています。)を変えたいと思うと、どうすれば良いのでしょうか。&lt;/p&gt;
&lt;p&gt;NPIVは、1つのHBAポートに対して、最大255個のWWPNを割り当てる技術です。&lt;br /&gt;
これを使って、各マシンごとにWWPNを割り当てることで、LUNからはきちんと個別のアクセス制御が行えることになります。&lt;/p&gt;
&lt;p&gt;NPIVを使うには、スイッチ側とHBA側の両方で対応している必要があります。&lt;/p&gt;
&lt;h2 id="vmware"&gt;VMware環境で利用する際の制限&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;スイッチ側でNPIVを有効化&lt;/li&gt;
&lt;li&gt;ホストのHBAがNPIVをサポートしている&lt;/li&gt;
&lt;li&gt;利用できる仮想マシンは、RDMディスクを持つもののみ&lt;/li&gt;
&lt;li&gt;1台の仮想マシンに対して、最大4つの仮想ポートを割り当てられる(つまり、最大4つのWWPNが割り当てられる)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常の仮想マシンが利用するWWNは、ホストの物理HBAのWWNを利用します。&lt;/p&gt;</summary><category term="VMware"></category><category term="VCP-DCV"></category><category term="NPIV"></category><category term="Storage"></category></entry><entry><title>VCP-DCVの概要 : VCP550</title><link href="http://www.hitsumabushi.org/2014/1230_0130.html" rel="alternate"></link><updated>2014-12-30T01:30:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-30:2014/1230_0130.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;資料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vcp-dcv"&gt;VCP-DCVの概要&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;バージョン&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;有効期限&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;必須条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;試験内容&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_6"&gt;試験時間&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;問題数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;合格点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;試験勉強に役立つもの&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#pre-test"&gt;pre-test&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#vcenter55-esxi"&gt;vCenter5.5 + ESXi環境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_10"&gt;書籍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;資料&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://mylearn.vmware.com/mgrReg/plan.cfm?plan=12457"&gt;VCP-Data Center Virtualization&lt;/a&gt;&lt;br /&gt;
受験を計画されている方は、Exam Blueprints というPDFを一読されることをお勧めします。&lt;/p&gt;
&lt;h2 id="vcp-dcv"&gt;VCP-DCVの概要&lt;/h2&gt;
&lt;h3 id="_2"&gt;バージョン&lt;/h3&gt;
&lt;p&gt;VCP-DCVという資格は、VMwareの製品バージョンに合わせて区別されています。&lt;br /&gt;
例えば、現在のvSphereのバージョンは、5.5が最新バージョンであるため、VCP5-DCV呼ばれています。&lt;/p&gt;
&lt;p&gt;さらに、試験については注意が必要で、VCP5-DCVという1つの資格に対して、2つのマイナーバージョンがあります。&lt;br /&gt;
それが、VCP510, VCP550で、vSphereのマイナーバージョンレベルでの違いです。&lt;br /&gt;
(他に前バージョンからのアップデート用試験もあります。Deltaみたいな感じで書かれていると、アップデート用試験です。)&lt;/p&gt;
&lt;h3 id="_3"&gt;有効期限&lt;/h3&gt;
&lt;p&gt;VCPの有効期限は、取得日から2年間です。&lt;/p&gt;
&lt;p&gt;延長の方法は、3つあります。&lt;br /&gt;
1. 同じ試験に合格する&lt;br /&gt;
2. 上位試験に合格する&lt;br /&gt;
3. 他の試験(例えば、VCP-Cloud)に合格する&lt;/p&gt;
&lt;h3 id="_4"&gt;必須条件&lt;/h3&gt;
&lt;p&gt;新しくVCP-DCVを取得しようとする場合、トレーニングを受講する必要があります。&lt;br /&gt;
5種類のうち、対応するバージョンのものを、どれか1つ受講すれば良いですが、初心者向けの1.を受講することが多いようです。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VMware vSphere: Install, Configure, Manage [V5.x]&lt;/li&gt;
&lt;li&gt;VMware vSphere: Fast Track [V5.x]&lt;/li&gt;
&lt;li&gt;VMware vSphere: Optimize and Scale [V5.x]&lt;/li&gt;
&lt;li&gt;VMware vSphere: Troubleshooting Workshop [V5.x]&lt;/li&gt;
&lt;li&gt;vSphere with Operations Management: Fast Track [V5.x]&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ただし、日本で開催されているトレーニングは3つしかないようですが...。&lt;/p&gt;
&lt;h2 id="_5"&gt;試験内容&lt;/h2&gt;
&lt;h3 id="_6"&gt;試験時間&lt;/h3&gt;
&lt;p&gt;120分&lt;br /&gt;
(+非英語圏の人は、+30分? 聞いている話だと日本語で受験できるはずなので、受験してみて確認します)&lt;/p&gt;
&lt;h3 id="_7"&gt;問題数&lt;/h3&gt;
&lt;p&gt;135問&lt;/p&gt;
&lt;h3 id="_8"&gt;合格点&lt;/h3&gt;
&lt;p&gt;300/500点&lt;/p&gt;
&lt;h2 id="_9"&gt;試験勉強に役立つもの&lt;/h2&gt;
&lt;h3 id="pre-test"&gt;pre-test&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://mylearn.vmware.com/mgrSurvey/assessLogin.cfm?item=24908&amp;amp;refer=0&amp;amp;p=0&amp;amp;ui=www_cert"&gt;VMware Certification&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="vcenter55-esxi"&gt;vCenter5.5 + ESXi環境&lt;/h3&gt;
&lt;p&gt;実機検証が何より役立つと思う。&lt;br /&gt;
あと5.5だとWeb Clientからしか使えない機能も増えているので、Web Clientを使っておいたほうが良いと予想している。&lt;/p&gt;
&lt;h3 id="_10"&gt;書籍&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://www.amazon.co.jp/gp/product/4798136808?adid=0GAHXG5HH7D1X9B0CH58&amp;amp;camp=1027&amp;amp;creative=7407&amp;amp;creativeASIN=4798136808&amp;amp;linkCode=as4&amp;amp;tag=test045d2-22"&gt;マスタリングVMware vSphere 5.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;個人的には、この本が一番良いと思っている。試験勉強中は、参照用に置いておくとはかどる。&lt;br /&gt;
実務でも役立つこと請け合いなので、試験が終わっても、とりあえず手元に持っておくと便利。&lt;/p&gt;</summary><category term="VMware"></category><category term="VCP-DCV"></category></entry><entry><title>fluentd-plugin-secure-forward のソースを読んでみる(Input プラグイン編)</title><link href="http://www.hitsumabushi.org/2014/1217_2345.html" rel="alternate"></link><updated>2014-12-17T23:45:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-17:2014/1217_2345.html</id><summary type="html">&lt;p&gt;本当は全部読もうと思っていたけど、想像以上に疲れたので、Inputだけにしました。&lt;br /&gt;
ただ、整理されているコードなので、Ruby知らなくても読みやすいのは読みやすいと思います。&lt;/p&gt;
&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;基本情報&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#fluentd-plugin-secure-forward"&gt;fluentd-plugin-secure-forward を読み始める&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;準備&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#in95secure95forward"&gt;in_secure_forward を読む&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#require-new"&gt;require &amp;amp; new&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#configure"&gt;configure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#start-shutdown"&gt;start &amp;amp; shutdown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;まとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2014-12-18"&gt;追記(2014-12-18)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;基本情報&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;lib/fluent/plugin/{TYPE}_{NAME}.rb 以下がプラグインの本体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TYPE : in, out, buf,... etc&lt;/li&gt;
&lt;li&gt;NAME : プラグインの名前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pluginを書く時のお約束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input(Output)プラグインは、module Fluentd内でInput(Output)プラグインを継承してクラスを定義する&lt;/li&gt;
&lt;li&gt;設定ファイル中で &lt;code&gt;type hoge&lt;/code&gt; と書きたいなら、&lt;code&gt;Fluent::Plugin.register_input('hoge', self)&lt;/code&gt; をクラス定義中に書く&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config_param&lt;/code&gt; を使うと、インスタンス変数が宣言できる。(実装はまだ読めていない)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fluentdの起動順序 : See &lt;a href="http://docs.fluentd.org/articles/plugin-development"&gt;docs.fluentd.org - plugin-development&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Fluent::Supervisor#run_configure&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;require&lt;/li&gt;
&lt;li&gt;new&lt;/li&gt;
&lt;li&gt;configure(conf)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fluent::Supervisor#run_engine&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;start&lt;/li&gt;
&lt;li&gt;shutdown&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="fluentd-plugin-secure-forward"&gt;fluentd-plugin-secure-forward を読み始める&lt;/h2&gt;
&lt;h3 id="_2"&gt;準備&lt;/h3&gt;
&lt;p&gt;何はともあれ、クローンしてきます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/tagomoris/fluent-plugin-secure-forward.git
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;fluent-plugin-secure-forward
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;さて、ライブラリの本体は、以下の通りです。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ls lib/fluent/plugin/
in_secure_forward.rb   input_session.rb       openssl_util.rb        out_secure_forward.rb  output_node.rb
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これを見ると、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in_secure_forward.rb&lt;/li&gt;
&lt;li&gt;out_secure_forward.rb&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;があるので、このプラグインは、 input, outputについてプラグインを作っているようです。&lt;/p&gt;
&lt;h3 id="in95secure95forward"&gt;in_secure_forward を読む&lt;/h3&gt;
&lt;h4 id="require-new"&gt;require &amp;amp; new&lt;/h4&gt;
&lt;p&gt;さっそく中を見てみます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;fluent/mixin/config_placeholders&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これは、&lt;a href="https://github.com/tagomoris/fluent-mixin-config-placeholders/blob/master/lib/fluent/mixin/config_placeholders.rb"&gt;github.com/tagomoris/fluent-mixin-config-placeholders&lt;/a&gt;を読んでいます。&lt;br /&gt;
動作については、&lt;a href="http://d.hatena.ne.jp/tagomoris/20120820/1345455837"&gt;http://d.hatena.ne.jp/tagomoris/20120820/1345455837&lt;/a&gt;に書いてありますが、fluentdの設定ファイル中のプレースホルダ(${...}みたいなの)を展開した状態で、変数に格納してくれるものらしいです。&lt;/p&gt;
&lt;p&gt;secure_forwardを使うときには、 &lt;code&gt;self_hostname&lt;/code&gt; で自分のホスト名を宣言しますが、その時にhostnameコマンドの結果で定義したいのが人情というものなので、その時に使われていそうです。&lt;br /&gt;
とりあえず、設定ファイル中の値を参照できることとして(configureメソッドの&lt;code&gt;super&lt;/code&gt;が呼ばれてから参照できます)、次に進みます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Fluent&lt;/span&gt;
  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SecureForwardInput&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Input&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これはお約束みたいなやつで、Inputプラグインは、Fluentモジュールの、Inputを継承したクラスとして定義するようです。中身は後で定義されています。&lt;/p&gt;
&lt;p&gt;先に進みます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;require_relative&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;input_session&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;これは暗号化するためのセッションを扱うものなので、後で考えます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;module&lt;/span&gt; &lt;span class="nn"&gt;Fluent&lt;/span&gt;
  &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SecureForwardInput&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Input&lt;/span&gt;
    &lt;span class="no"&gt;DEFAULT_SECURE_LISTEN_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;24284&lt;/span&gt;

    &lt;span class="no"&gt;Fluent&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Plugin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;register_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;secure_forward&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="n"&gt;config_param&lt;/span&gt; &lt;span class="ss"&gt;:self_hostname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:string&lt;/span&gt;
    &lt;span class="kp"&gt;include&lt;/span&gt; &lt;span class="no"&gt;Fluent&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Mixin&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;ConfigPlaceholders&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ここで大事そうなのは、 &lt;code&gt;Fluent::Plugin.register_input('secure_forward', self)&lt;/code&gt;です。&lt;br /&gt;
これを書いておくと、fluentd.conf(のinputセクション)で &lt;code&gt;type secure_forward&lt;/code&gt; と書いたとき、このプラグインを使います。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="c1"&gt;# Define `log` method for v0.10.42 or earlier&lt;/span&gt;
    &lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="nb"&gt;method_defined?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:log&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;define_method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;log&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="vg"&gt;$log&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;昔はlogを出すときに$logと書いていたけども、今はlogと書く、という差を吸収するための設定みたいです。&lt;/p&gt;
&lt;h4 id="configure"&gt;configure&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;configure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;super&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
      &lt;span class="vi"&gt;@clients&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="vi"&gt;@nodes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
            &lt;span class="ss"&gt;address&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;source_addr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="ss"&gt;shared_key&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shared_key&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="vi"&gt;@shared_key&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="ss"&gt;users&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;users&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="p"&gt;})&lt;/span&gt;
      &lt;span class="k"&gt;end&lt;/span&gt;

      &lt;span class="vi"&gt;@generate_cert_common_name&lt;/span&gt; &lt;span class="o"&gt;||=&lt;/span&gt; &lt;span class="vi"&gt;@self_hostname&lt;/span&gt;
      &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;certificate&lt;/span&gt;
      &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最初の superで、fluent/mixin/config_placeholders を使って、hostnameのプレースホルダーを展開した値を参照できるようになりました。次に、&lt;code&gt;@clients&lt;/code&gt; になにが入ってるかといえば、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;config_section&lt;/span&gt; &lt;span class="ss"&gt;:client&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;param_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="ss"&gt;:clients&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
      &lt;span class="n"&gt;config_param&lt;/span&gt; &lt;span class="ss"&gt;:host&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;nil&lt;/span&gt;
      &lt;span class="n"&gt;config_param&lt;/span&gt; &lt;span class="ss"&gt;:network&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;nil&lt;/span&gt;
      &lt;span class="n"&gt;config_param&lt;/span&gt; &lt;span class="ss"&gt;:shared_key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;nil&lt;/span&gt;
      &lt;span class="n"&gt;config_param&lt;/span&gt; &lt;span class="ss"&gt;:users&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kp"&gt;nil&lt;/span&gt; &lt;span class="c1"&gt;# comma separated username list&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;というのがあるので、設定ファイル中 &amp;lt;client&amp;gt;セクションで定義している中身が入っていることになります。&lt;br /&gt;
source_addrというのは、クライアントのアドレス、またはネットワークアドレスで、shared_keyとuserと一緒にpushしています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;self.certificate&lt;/code&gt;というのを見てみると、@certと@keyが宣言されていないとき、証明書とキーを生成して、@cert, @keyとして定義するものです。このときコモンネームは、&lt;code&gt;@generate_cert_common_name ||= @self_hostname&lt;/code&gt;から決まっているので、指定がないならホスト名になります。&lt;/p&gt;
&lt;h4 id="start-shutdown"&gt;start &amp;amp; shutdown&lt;/h4&gt;
&lt;p&gt;さて、configureは読んだので、実行時の挙動を調べます。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;start&lt;/span&gt;
      &lt;span class="k"&gt;super&lt;/span&gt;
      &lt;span class="no"&gt;OpenSSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;File&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;/dev/urandom&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
      &lt;span class="vi"&gt;@sessions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;[]&lt;/span&gt;
      &lt;span class="vi"&gt;@sock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;nil&lt;/span&gt;
      &lt;span class="vi"&gt;@listener&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nb"&gt;method&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:run&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;shutdown&lt;/span&gt;
      &lt;span class="vi"&gt;@listener&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;kill&lt;/span&gt;
      &lt;span class="vi"&gt;@listener&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;
      &lt;span class="vi"&gt;@sessions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;each&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;shutdown&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
      &lt;span class="vi"&gt;@sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;特に、変なところはないですが、&lt;code&gt;@listener, @session&lt;/code&gt; の中身が気になるところです。早速 runの中身を見てみましょう。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt; &lt;span class="c1"&gt;# sslsocket server thread&lt;/span&gt;
      &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;setup for ssl sessions&amp;quot;&lt;/span&gt;
      &lt;span class="n"&gt;cert&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;certificate&lt;/span&gt;
      &lt;span class="n"&gt;ctx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;OpenSSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;SSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;SSLContext&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;
      &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cert&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cert&lt;/span&gt;
      &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;

      &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;start to listen&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:bind&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="vi"&gt;@bind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:port&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="vi"&gt;@port&lt;/span&gt;
      &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;TCPServer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vi"&gt;@bind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="vi"&gt;@port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;starting SSL server&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:bind&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="vi"&gt;@bind&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:port&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="vi"&gt;@port&lt;/span&gt;
      &lt;span class="vi"&gt;@sock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;OpenSSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;SSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;SSLServer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="vi"&gt;@sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_immediately&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;false&lt;/span&gt;
      &lt;span class="k"&gt;begin&lt;/span&gt;
        &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;accepting sessions&amp;quot;&lt;/span&gt;
        &lt;span class="kp"&gt;loop&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
          &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@sock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;
            &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;accept tcp connection (ssl session not established yet)&amp;quot;&lt;/span&gt;
            &lt;span class="vi"&gt;@sessions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="no"&gt;Session&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

            &lt;span class="c1"&gt;# cleanup closed session instance&lt;/span&gt;
            &lt;span class="vi"&gt;@sessions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delete_if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="ss"&gt;:closed?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;log&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;trace&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;session instances:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:all&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="vi"&gt;@sessions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;:closed&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="vi"&gt;@sessions&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="ss"&gt;:closed?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;
          &lt;span class="k"&gt;end&lt;/span&gt;
        &lt;span class="k"&gt;end&lt;/span&gt;
      &lt;span class="k"&gt;rescue&lt;/span&gt; &lt;span class="no"&gt;OpenSSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;SSL&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;SSLError&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="k"&gt;unless&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start_with?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;SSL_accept SYSCALL&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# signal trap on accept&lt;/span&gt;
      &lt;span class="k"&gt;end&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;あまりOpenSSL:SSL::SSLserverについて調べていないですが、パッと見、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;設定されている証明書, キーでSSLサーバーを立てて、loopで待ち続ける&lt;/li&gt;
&lt;li&gt;テキトーなポート,バインドでリッスンする&lt;/li&gt;
&lt;li&gt;TCPコネクションが確立されるごとに @sessions に格納していく (&lt;code&gt;@sock.start_immediately = false&lt;/code&gt;としているので、&lt;a href="http://docs.ruby-lang.org/ja/2.1.0/method/OpenSSL=3a=3aSSL=3a=3aSSLServer/i/accept.html"&gt;SSLはまだハンドシェイクできてない&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;セッションが切れるたびに、@sessionsから削除する&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;という動作みたいです。特に3.について、なぜこの実装なのかはわかっていないです。&lt;br /&gt;
あと、ここで &lt;code&gt;@sessions.push Session.new(self, socket)&lt;/code&gt;という部分がありますが、ここのSessionは、input_session.rb で定義されているものです。&lt;br /&gt;
こっちの方がこのプラグインの肝な感じですが、Fluentdのプラグインの作り方とはあまり関係ないので、見ないことにします。(最初にping pongをやって、それが終わってから、ソケットを読みにいってはon_messageを呼ぶ、みたいなことをしているみたいです)&lt;/p&gt;
&lt;p&gt;とりあえず、以上でざっくりと Inputプラグインの中身がわかりました。&lt;/p&gt;
&lt;h2 id="_3"&gt;まとめ&lt;/h2&gt;
&lt;p&gt;Inputプラグインの場合は、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;configure(config)&lt;/li&gt;
&lt;li&gt;start&lt;/li&gt;
&lt;li&gt;stop&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;に集中して読み始めるとわかりやすいと思いました。&lt;br /&gt;
その他は割と雑多なので、困った時に読めば良さそうです。&lt;/p&gt;
&lt;h2 id="2014-12-18"&gt;追記(2014-12-18)&lt;/h2&gt;
&lt;blockquote class="twitter-tweet" lang="en"&gt;&lt;p&gt;&lt;a href="https://twitter.com/_hitsumabushi_"&gt;@_hitsumabushi_&lt;/a&gt; acceptするのはFluentd in_secure_forwardのメインスレッドだけど SSL handshake は割とコストが高い処理なので、それを input_session 側のスレッドにやらせたい、という理由ですね&lt;/p&gt;&amp;mdash; tagomoris (@tagomoris) &lt;a href="https://twitter.com/tagomoris/status/545235797960425472"&gt;December 17,  2014&lt;/a&gt;&lt;/blockquote&gt;

&lt;script async src="//platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;</summary><category term="Ruby"></category><category term="Fluentd"></category></entry><entry><title>VMware 環境でのMACアドレス割当て</title><link href="http://www.hitsumabushi.org/2014/1217_1440.html" rel="alternate"></link><updated>2014-12-17T14:40:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-17:2014/1217_1440.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#1"&gt;1. まとめ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#2-mac"&gt;2. MACアドレスの割当て方式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#vcenter"&gt;vCenterによる自動割当て&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#vmware-oui"&gt;VMware OUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;プレフィックスベース&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;範囲ベース&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#vcenteresxi"&gt;vCenterに接続されていないESXiにより自動割当て&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;固定割当て&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#3-mac"&gt;3. MACアドレスが足りなくなった時の動作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#4"&gt;4. 資料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="1"&gt;1. まとめ&lt;/h2&gt;
&lt;p&gt;vSphere環境上のMACアドレス割当の方式は、複数あります。自分のOUIを割当てたい!!、という場合には、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vCenter環境でプレフィックス指定&lt;/li&gt;
&lt;li&gt;固定割当て&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;といった方法を使いましょう&lt;/p&gt;
&lt;h2 id="2-mac"&gt;2. MACアドレスの割当て方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;vCenterによる自動割当て&lt;ol&gt;
&lt;li&gt;VMware OUI&lt;/li&gt;
&lt;li&gt;プレフィックスベース&lt;/li&gt;
&lt;li&gt;範囲ベース&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;vCenterに接続されていないESXiによる自動割当て&lt;/li&gt;
&lt;li&gt;手動での割当て&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="vcenter"&gt;vCenterによる自動割当て&lt;/h3&gt;
&lt;p&gt;設定の変更は、vSphere Web Clientから行うか、vpxd.cfgから行います。&lt;/p&gt;
&lt;h4 id="vmware-oui"&gt;VMware OUI&lt;/h4&gt;
&lt;p&gt;これがデフォルトの設定ですが、00:50:56:{XX}:{YY}:{ZZ} という割当てを行います。&lt;br /&gt;
ただし、XX = {vCenterのid} + 0x80 で決めています。&lt;br /&gt;
そういうわけで、XXはvCenterごとに固定なので、65536個だけ利用可能だということになります。&lt;/p&gt;
&lt;p&gt;普通は、こんなにMACアドレスを使う前に、他の上限値(VM作成上限数やvCPU上限など)にぶち当たって悲しみを抱えるので、大丈夫だと思われます。&lt;br /&gt;
複数のvCenterを利用している人は、vCenter間でIDがかぶっていないことは確認する必要があります。&lt;/p&gt;
&lt;p&gt;この割当て方式では、00:50:56:80:{YY}:{ZZ} - 00:50:56:BF:{YY}:{ZZ} までの範囲が割当てられるので、見ればわかります。&lt;/p&gt;
&lt;p&gt;以下が vpxd.cfgでの例です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;vpxd&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;macAllocScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;VMwareOUI&amp;gt;&lt;/span&gt;true&lt;span class="nt"&gt;&amp;lt;/VMwareOUI&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/macAllocScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/vpxd&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id="_1"&gt;プレフィックスベース&lt;/h4&gt;
&lt;p&gt;5.1以降の環境では、デフォルトの00:50:56以外のプレフィックスを指定できます。&lt;br /&gt;
また、個数が足りない時には LAA(ローカル管理アドレス)プレフィックスを使うこともできます。&lt;br /&gt;
自分のOUIを使いたいときとか、複数vCenterがある時にLAA使う場合に使いそうです。&lt;/p&gt;
&lt;p&gt;以下の設定は、00:50:26または、00:50:27から始まるMACアドレスを割当てる例です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;vpxd&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;macAllocScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;prefixScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;prefix&amp;gt;&lt;/span&gt;005026&lt;span class="nt"&gt;&amp;lt;/prefix&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;prefixLength&amp;gt;&lt;/span&gt;23&lt;span class="nt"&gt;&amp;lt;/prefixLength&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/prefixScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/macAllocScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/vpxd&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4 id="_2"&gt;範囲ベース&lt;/h4&gt;
&lt;p&gt;開始と終了のMACアドレスを指定するものです。&lt;br /&gt;
LAAの複数の範囲を指定できるので、便利かもしれません。&lt;/p&gt;
&lt;p&gt;これも複数vCenterを使うときには、分割して使えるので便利だと思います。&lt;/p&gt;
&lt;p&gt;たぶん、こっちの方が、後で拡張したいときには便利なので、(そんなことあるのか知らないけど、)自由に使えるMACアドレス数が少ない場合には、後で追加しやすくて便利だと思います。&lt;/p&gt;
&lt;p&gt;以下が、範囲ベース割当ての例です。 range idは0から始まります。 以下の例では、00:50:67:00:00:01のみの範囲1つだけを利用する例です。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;vpxd&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;macAllocScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;rangeScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;range&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;begin&amp;gt;&lt;/span&gt;005067000001&lt;span class="nt"&gt;&amp;lt;/begin&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;end&amp;gt;&lt;/span&gt;005067000001&lt;span class="nt"&gt;&amp;lt;/end&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/range&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/rangeScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/macAllocScheme&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/vpxd&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="vcenteresxi"&gt;vCenterに接続されていないESXiにより自動割当て&lt;/h3&gt;
&lt;p&gt;これが利用されるのは、&lt;br /&gt;
1. vCenterに接続されていない&lt;br /&gt;
2. vmxファイルに、MACアドレスやMACアドレス割当てタイプが書かれていない&lt;br /&gt;
場合です。&lt;/p&gt;
&lt;p&gt;割当てられるMACアドレスは 00:0C:29 + {UUIDの最後の3オクテット} です。&lt;/p&gt;
&lt;h3 id="_3"&gt;固定割当て&lt;/h3&gt;
&lt;p&gt;デフォルトのOUIは 00:50:56 です。&lt;br /&gt;
このOUIを利用する場合、上で見たように他の用途で使われる箇所は予約されています。そのため、 00:50:56:00:{YY}:{ZZ} - 00:50:56:3F:{YY}:{ZZ} のみが利用可能です。&lt;/p&gt;
&lt;p&gt;これを利用するためには、以下を削除して、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ethernetN.generatedAddress
ethernetN.addressType
ethernetN.generatedAddressOffset
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以下を記述します。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ethernetN.addressType = static
ethernetN.address     = {MAC ADDRESS}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="3-mac"&gt;3. MACアドレスが足りなくなった時の動作&lt;/h2&gt;
&lt;p&gt;起動されるときに、MACアドレスが生成されます。&lt;br /&gt;
基本的には、起動中のMACアドレスとの衝突しか検知しないので、仮想マシンを一時的に停止している場合、再起動したときに、たまにMACアドレスが変更されてしまうことがありえます。&lt;/p&gt;
&lt;h2 id="4"&gt;4. 資料&lt;/h2&gt;
&lt;p&gt;vSphere ネットワークガイド&lt;br /&gt;
- MACアドレスの管理&lt;/p&gt;</summary><category term="VMware"></category></entry><entry><title>ソースコードリーディングをするときにctagsを使いたい</title><link href="http://www.hitsumabushi.org/2014/1216_2000.html" rel="alternate"></link><updated>2014-12-16T20:00:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-16:2014/1216_2000.html</id><summary type="html">&lt;h2 id="_1"&gt;きっかけ&lt;/h2&gt;
&lt;p&gt;とある事情によって、Fluentdプラグインを自作する or 世間の良い実装のプラグインを見つける必要がありました。&lt;br /&gt;
でも、Fluentdを真面目に使ったことがないので、いまいち眺めていても難しいなー、と思っていました。&lt;br /&gt;
そもそも、Rubyもまともに書いていないため、ソースを見ても、Rubyのものなのか、Fluentdで定義されているのかが、&lt;br /&gt;
ぱっと見でわからず、いちいち時間がかかっていた感じです。&lt;/p&gt;
&lt;p&gt;ソースコードを読む上で支援してくれるものがあったらなー、と思っていたら、タグをつけると良いと聞いたので、やってみます。&lt;/p&gt;
&lt;h2 id="_2"&gt;流れ&lt;/h2&gt;
&lt;p&gt;今回はmacでやることにします。&lt;br /&gt;
brew がインストールしてあることにしています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Exuberant Ctagsのインストール&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;brew install ctags
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tagの生成(Emacsから使うには、etagsと呼ばれる形式で生成)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# 読みたいソースのトップに移動&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; /home/me/app
&lt;span class="c"&gt;# タグの生成 (Emacs の場合)&lt;/span&gt;
ctags -Re
&lt;span class="c"&gt;# タグの生成 (Vim の場合)&lt;/span&gt;
ctags -R
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;コードリーディング&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Emacs の場合&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;キー&lt;/th&gt;
&lt;th&gt;意味&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;M-.&lt;/td&gt;
&lt;td&gt;ジャンプ(関数, クラス)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C-u M-.&lt;/td&gt;
&lt;td&gt;次の検索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C-u – M-.&lt;/td&gt;
&lt;td&gt;前の検索&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M-*&lt;/td&gt;
&lt;td&gt;元の場所&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Vim の場合&lt;/p&gt;
&lt;p&gt;いつも以下のサイトを参考にして生きている。&lt;/p&gt;
&lt;p&gt;http://archiva.jp/web/tool/vim_ctags.html&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Emacs"></category><category term="Ruby"></category></entry><entry><title>drone.ioを使って、pelicanをビルドする</title><link href="http://www.hitsumabushi.org/2014/1215_2300.html" rel="alternate"></link><updated>2014-12-15T23:00:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-12-15:2014/1215_2300.html</id><summary type="html">&lt;h2 id="_1"&gt;動機&lt;/h2&gt;
&lt;p&gt;最近はWordpressでブログをやっていたけど、&lt;br /&gt;
あくまで Wordpressを使う人の気持ちがわかりたかったので、使ってたのでした。&lt;br /&gt;
そろそろ、Wordpressの便利さもわかってきたし、vimとかemacsから書きやすいものを使いたいなー、と思ってました。&lt;/p&gt;
&lt;p&gt;そこで&lt;a href="http://docs.getpelican.com/en/3.5.0/index.html"&gt;pelican&lt;/a&gt;ですよ。&lt;/p&gt;
&lt;p&gt;OctpressとかSphinxとかで書いても良いんですが、なんとなく微妙な修正だったり、追加のプラグインが必要だったので、気分がのらなかったのです。&lt;br /&gt;
pelicanは割と軽量っぽく見えたのと、reStructuredTextでもMarkdownでも書けるのが、自分には気楽だったから採用しました。&lt;/p&gt;
&lt;h2 id="_2"&gt;やり方&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;drone.io で New Project -&amp;gt; Github -&amp;gt; 適当なリポジトリを選ぶ&lt;/li&gt;
&lt;li&gt;drone.io で Settings -&amp;gt; Repository -&amp;gt; View Key をクリックすると、SSH keyが表示される。&lt;/li&gt;
&lt;li&gt;Githubの自分のリポジトリで、Settings -&amp;gt; Deploy keys に追加する&lt;/li&gt;
&lt;li&gt;後は、自分のビルドの設定をして、ビルドするなり、git pushするなりするだけ。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_3"&gt;困った...?と思ったこと&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SSHキーがどこから見るのかわからなくて、git pushできないかと思って焦りました。&lt;/li&gt;
&lt;li&gt;いい感じにgit pushするスクリプトがなかったので、変なデプロイ用のシェルを書くことになった。しかも、毎回 gh-pages にforce pushするという感じになってしまった。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_4"&gt;感想&lt;/h2&gt;
&lt;p&gt;まだテーマとかいじってないので、テーマをいじるかも。&lt;br /&gt;
テーマいじらないとタグクラウドの設定ができないっぽいので。&lt;br /&gt;
使ってみた感じ、割とブログには便利だと思うなー。&lt;/p&gt;</summary><category term="CI"></category><category term="drone.io"></category><category term="pelican"></category></entry><entry><title>vSphere API事始め</title><link href="http://www.hitsumabushi.org/2014/0814_1639.html" rel="alternate"></link><updated>2014-08-14T16:39:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-08-14:2014/0814_1639.html</id><summary type="html">&lt;h2 id="_1"&gt;リファレンス&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://www.vmware.com/support/developer/vc-sdk/&lt;/li&gt;
&lt;li&gt;https:// "vcenter_ip" /mob/&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;参考サイト&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;http://thinkit.co.jp/story/2010/06/23/1617&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="overview"&gt;Overview&lt;/h1&gt;
&lt;h2 id="types"&gt;Types&lt;/h2&gt;
&lt;p&gt;4つのタイプがある。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;vSphere APIの型&lt;/th&gt;
&lt;th&gt;普通のプログラミングとの類推&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;managed object type&lt;/td&gt;
&lt;td&gt;プリミティブ型、複合型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data object type&lt;/td&gt;
&lt;td&gt;抽象データ型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;enumerated type&lt;/td&gt;
&lt;td&gt;定数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Fault type&lt;/td&gt;
&lt;td&gt;例外型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="1-managed-object-types"&gt;1. Managed object types&lt;/h3&gt;
&lt;h4 id="managed-object-type"&gt;Managed object typeとは&lt;/h4&gt;
&lt;p&gt;(サーバーサイドのオブジェクトモデルの基本的なデータを担っている。data objectも同じく。)&lt;br /&gt;
managed objectには、大きく2つの種類がある。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ManagedEntity を拡張したもので、仮想コンポーネントのインベントリとして使われている。&lt;br /&gt;
    "managed entities"と呼ばれることもある。&lt;/p&gt;
&lt;p&gt;例えば以下のようなものがある。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;| HostSystem     | ホストシステムのインスタンス |
| VirtualMachine | VM                     |
| Datastore      | データストア              |
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;システム全体のための、サービスを提供するもの。&lt;br /&gt;
    例えば、以下のもの。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;| PerfomanceManager  | パフォーマンス管理         |
| LicenseManager     | VMware製品のライセンス管理 |
| VirtualDiskManager | 仮想ストレージの管理       |
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="managed-object-type_1"&gt;Managed object typeの使い方&lt;/h4&gt;
&lt;p&gt;使いはじめるには、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;connect : サーバーに接続&lt;/li&gt;
&lt;li&gt;authenticate :認証を通す&lt;/li&gt;
&lt;li&gt;session : セッションを得る&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;というステップがある。&lt;/p&gt;
&lt;p&gt;セッションを貼った後は、&lt;em&gt;ServiceInstance&lt;/em&gt; という managed objectを得る。&lt;br /&gt;
ServiceInstance の下には、 Data object typesがぶら下がっている。&lt;br /&gt;
以下の図で、"MOR"というのは、 &lt;em&gt;ManagedObjectRefarence&lt;/em&gt; の略で、&lt;br /&gt;
これは、server-side object へのリファレンスを与えるdata objectである。&lt;/p&gt;
&lt;p&gt;※図は&lt;a href="http://pubs.vmware.com/vsphere-50/index.jsp#com.vmware.wssdk.apiref.doc_50/mo-types-landing.html"&gt;vmwareのドキュメント&lt;/a&gt;から。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ServiceInstance_TopLevel_Figure" src="../images/2014/ServiceInstance_TopLevel_Figure.gif" /&gt;&lt;br /&gt;
凡例&lt;br /&gt;
&lt;img alt="legend_figures" src="../images/2014/legend_figures.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;managed obejectは、property と operation(method)を持っている。&lt;/p&gt;
&lt;h3 id="2-data-object-types"&gt;2. Data object types&lt;/h3&gt;
&lt;h4 id="data-object-type"&gt;Data object typeとは&lt;/h4&gt;
&lt;p&gt;Javaでいう抽象データ型や、C++でいうstructデータ型のようなもの。&lt;br /&gt;
managed object typeが、プリミティブデータ型だったり、複合データ型だったりする。&lt;br /&gt;
(vSphere API的な意味での、プリミティブデータ型は、 XML Schemeプリミティブで書かれている。例えば、xsd:string とか。)&lt;/p&gt;
&lt;p&gt;※図は&lt;a href="http://pubs.vmware.com/vsphere-50/index.jsp#com.vmware.wssdk.apiref.doc_50/do-types-landing.html"&gt;vmwareのドキュメント&lt;/a&gt; から。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ServiceInstance_AboutInfo_Detail" src="../images/2014/ServiceInstance_AboutInfo_Detail.gif" /&gt;&lt;/p&gt;
&lt;h4 id="data-object-type_1"&gt;Data object typeの例&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;data object&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AlarmInfo&lt;/td&gt;
&lt;td&gt;AlarmSpecから継承するプロパティ + ManagedObjectReference(Alarm managed objectへのリファレンス)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ManagedObjectReference&lt;/td&gt;
&lt;td&gt;MOR, reference, MoRefとか呼ばれる。server-side managed objectのリファレンス&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="3-enumerated-types-enumeration"&gt;3. Enumerated types (enumeration)&lt;/h3&gt;
&lt;p&gt;予め定義されている値や予め定義されたオブジェクトが保管されているオブジェクト。&lt;br /&gt;
つまり、定数のように使われる。&lt;/p&gt;
&lt;p&gt;| VirtualMachinePowerState | VMの起動状態を持っている。 poweredOff,poweredOn,suspended |&lt;/p&gt;
&lt;h3 id="4-fault-types"&gt;4. Fault types&lt;/h3&gt;
&lt;p&gt;サーバーによってあげられる例外。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Fault&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NotSuported&lt;/td&gt;
&lt;td&gt;呼ばれたメソッドがサーバーでサポートされていなかったとき。vCetnerのメソッドをESXiで呼んだりとかの場合も。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NoPermission&lt;/td&gt;
&lt;td&gt;clientユーザーの権限が足りないとき。権限が必要だった、MORを含んで返してくれる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary><category term="VMware"></category></entry><entry><title>IPv6のことを調べ始めた</title><link href="http://www.hitsumabushi.org/2014/0812_1638.html" rel="alternate"></link><updated>2014-08-12T16:38:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-08-12:2014/0812_1638.html</id><summary type="html">&lt;h2 id="ipv6"&gt;IPv6 環境構築&lt;/h2&gt;
&lt;h3 id="rfc"&gt;ひとまず参照すべきRFC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RFC3315(DHCPv6) とそれをupdateしているやつ&lt;/li&gt;
&lt;li&gt;RFC4861(Neighbor DiscoveryのIPv6バージョン)&lt;/li&gt;
&lt;li&gt;RFC5942(IPv6のsubnet model)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ipv6_1"&gt;IPv6 アドレス配布方式について&lt;/h3&gt;
&lt;p&gt;全体としては、下記の4パターンある。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;アドレス配布方式&lt;/th&gt;
&lt;th&gt;RAは必要?&lt;/th&gt;
&lt;th&gt;RAにプレフィックス情報は必要?&lt;/th&gt;
&lt;th&gt;m-flag&lt;/th&gt;
&lt;th&gt;o-flag&lt;/th&gt;
&lt;th&gt;配布できるもの&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;手動&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ステートレスアドレス自動設定(SLAAC)&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;off&lt;/td&gt;
&lt;td&gt;off&lt;/td&gt;
&lt;td&gt;プレフィックスのみ&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ステートフルDHCPv6&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;o(たぶん。)&lt;/td&gt;
&lt;td&gt;on&lt;/td&gt;
&lt;td&gt;on&lt;/td&gt;
&lt;td&gt;IPアドレスとDUIDの組, DNSなど&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ステートレスDHCPv6&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;off&lt;/td&gt;
&lt;td&gt;on&lt;/td&gt;
&lt;td&gt;DNSなど&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;よく使われそうな、SLAACとステートフルDHCPv6には、以下のようなメリット・デメリットがある。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th align="center"&gt;メリット&lt;/th&gt;
&lt;th align="center"&gt;デメリット&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SLAAC&lt;/td&gt;
&lt;td align="center"&gt;ルーター設定のみでOK&lt;/td&gt;
&lt;td align="center"&gt;IPを固定化しづらい&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ステートフルDHCPv6&lt;/td&gt;
&lt;td align="center"&gt;DHCPDを立てる必要あり&lt;/td&gt;
&lt;td align="center"&gt;IP固定化できる。DNS情報もその気になれば配布できる&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary><category term="IPv6"></category></entry><entry><title>DebianにOzをインストールする</title><link href="http://www.hitsumabushi.org/2014/0727_1637.html" rel="alternate"></link><updated>2014-07-27T16:37:00+09:00</updated><author><name>hitsumabushi</name></author><id>tag:www.hitsumabushi.org,2014-07-27:2014/0727_1637.html</id><summary type="html">&lt;p&gt;ガウディ本読みはじめた。&lt;/p&gt;
&lt;iframe src="http://rcm-fe.amazon-adsystem.com/e/cm?lt1=_blank&amp;bc1=000000&amp;IS2=1&amp;nou=1&amp;bg1=FFFFFF&amp;fc1=000000&amp;lc1=0000FF&amp;t=l0fb-22&amp;o=9&amp;p=8&amp;l=as4&amp;m=amazon&amp;f=ifr&amp;ref=ss_til&amp;asins=4798113468" style="width:120px;height:240px;" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"&gt;&lt;/iframe&gt;

&lt;h2 id="_1"&gt;困ったこと&lt;/h2&gt;
&lt;p&gt;この本で使われるOzという言語をDebian上で実行するのに、少し困った。&lt;br /&gt;
morzart2をダウンロードして、適当にインストールしただけだと、&lt;br /&gt;
emacs上でコンパイルはできるのに、実行結果が表示できない状況になった。&lt;br /&gt;
正常な動作は、コンパイルできるとウィンドウが開いて、そこに結果が表示される。&lt;/p&gt;
&lt;p&gt;このために、必要なパッケージがあるので、それを予めインストールしておくと良い。&lt;/p&gt;
&lt;h2 id="_2"&gt;インストール手順&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;必要なパッケージをインストール&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install tcl tk8.5
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最初は、tk8.5ではなく、tkを指定して、tk8.6だけがインストールされていた。&lt;br /&gt;
  この状況では、結果が表示されない。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;morzart2のダウンロード&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下のページからダウンロード。(Githubからでも良い)&lt;br /&gt;
&lt;a href="http://sourceforge.net/projects/mozart-oz/files/"&gt;Source Forge&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;morzart2の展開&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;tar xf &lt;span class="s2"&gt;&amp;quot;ダウンロードしたファイル&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;実行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;展開したディレクトリ&amp;quot;&lt;/span&gt;
bin/oz
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;こんな感じ。&lt;br /&gt;
必要ならパスを通しておくと良い。&lt;/p&gt;</summary><category term="Debian"></category><category term="CTMCP"></category></entry></feed>